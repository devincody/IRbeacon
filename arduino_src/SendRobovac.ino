/* rawSend.ino Example sketch for IRLib2
 *  Illustrates how to send a code Using raw timings which were captured
 *  from the "rawRecv.ino" sample sketch.  Load that sketch and
 *  capture the values. They will print in the serial monitor. Then you
 *  cut and paste that output into the appropriate section below.
 */
#include <IRLibSendBase.h>    //We need the base code
#include <IRLib_HashRaw.h>    //Only use raw sender

// Libraries generated by IRLib rawRECV
#include "SendRobovac.h"
#include "OscillatingFanIR.h"
#include "TelevisionIR.h"

IRsendRaw mySender;
unsigned long previousMillis = 0;
unsigned long currentMillis = 0;
uint16_t local_sig[HOME_DATA_LEN]; //PROGMEM data needs to be moved locally or the data won't be sent on time
int ledState = LOW;
char datac = '\0';
int good_cmd = 1;

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, HIGH); 
  Serial.begin(9600);
  delay(2000); while (!Serial); //delay for Leonardo
  Serial.println(F("Every time you press a key is a serial monitor we will send."));
  digitalWrite(LED_BUILTIN, LOW);
  
}

void setLED(int * led_state, unsigned long *previous_ms, unsigned long current_ms){
  digitalWrite(LED_BUILTIN, HIGH);
  *led_state = HIGH;
  *previous_ms = current_ms;
}
   
void loop() {
  currentMillis = millis();
  if(Serial.available() > 0){
    datac = Serial.read();
    good_cmd = 1;

    // Send code based on which characters are received
    switch(datac){
      // Robovac
      case 'h':
        for (int i = 0; i < HOME_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&home_Data[i]);
        }
        break;
      case 'a':
        for (int i = 0; i < AUTO_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&auto_Data[i]);
        }
        break;
      case 'x':
        for (int i = 0; i < AUTO_MAX_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&auto_max_Data[i]);
        }
        break;
      case 'u':
        for (int i = 0; i < UP_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&up_Data[i]);
        }
        break;
      case 'l':
        for (int i = 0; i < LEFT_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&left_Data[i]);
        }
        break;
      case 'r':
        for (int i = 0; i < RIGHT_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&right_Data[i]);
        }
        break;
      case 'd':
        for (int i = 0; i < DOWN_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&down_Data[i]);
        }
        break;
      case 't':
        for (int i = 0; i < STOP_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&stop_Data[i]);
        }
        break;
      case 'w':
        for (int i = 0; i < SPOT_SWIRL_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&spot_swirl_Data[i]);
        }
        break;
      case 'e':
        for (int i = 0; i < EDGE_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&edge_Data[i]);
        }
        break;
      // Oscillating Fan
      case 'f':
        for (int i = 0; i < ON_OFF_RAW_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&ON_OFF[i]);
        }
        break;
      case 'p':
        for (int i = 0; i < SPEED_RAW_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&SPEED[i]);
        }
        break;
      case 'i':
        for (int i = 0; i < OSC_RAW_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&OSC[i]);
        }
        break;
      case 'm':
        for (int i = 0; i < TIMER_RAW_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&TIMER[i]);
        }
        break;
      // TV
      case 'o':
        for (int i = 0; i < TV_PWR_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&tv_remote_power_Data[i]);
        }
        break;
      case 'v':
        for (int i = 0; i < TV_VOL_UP_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&tv_remote_volume_up_Data[i]);
        }
        break;
      case 'z':
        for (int i = 0; i < TV_VOL_DWN_RAW_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&tv_remote_volume_down_DataData[i]);
        }
        break;
      case 'q':
        for (int i = 0; i < TV_MUTE_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&tv_remote_mute_Data[i]);
        }
        break;
      case 'y':
        for (int i = 0; i < TV_PLAY_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&tv_remote_play_Data[i]);
        }
        break;
      case 'n':
        for (int i = 0; i < TV_PAUSE_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&tv_remote_pause_Data[i]);
        }
        break;
      case 'c':
        for (int i = 0; i < TV_FORWARD_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&tv_remote_forward_Data[i]);
        }
        break;
      case 'b':
        for (int i = 0; i < TV_BACKWARD_DATA_LEN; i++){
          local_sig[i] = pgm_read_word(&tv_remote_backwards_Data[i]);
        }
        break;
      default:
        good_cmd = 0;
        break;
    }
    
    if (good_cmd == 1){
      mySender.send(local_sig, HOME_DATA_LEN, 36);
      setLED(&ledState, &previousMillis, currentMillis);
      Serial.println(F("Sent signal."));
    }
  }
  
  if (currentMillis - previousMillis >= 500 && ledState == HIGH){
    digitalWrite(LED_BUILTIN, LOW);
    ledState = LOW;
  }
}
